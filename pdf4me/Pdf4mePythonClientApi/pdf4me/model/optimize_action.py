# coding: utf-8

"""
    Pdf4me

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: v1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from pdf4me.model.key_value_pair_string_string import KeyValuePairStringString  # noqa: F401,E501


class OptimizeAction(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'profile': 'str',
        'use_profile': 'bool',
        'remove_redundant_objects': 'bool',
        'subset_fonts': 'bool',
        'optimize_resources': 'bool',
        'force_compression_types': 'bool',
        'force_recompression': 'bool',
        'reduce_color_complexity': 'bool',
        'merge_embedded_fonts': 'bool',
        'bitonal_compressions': 'list[str]',
        'bitonal_resolution_dpi': 'float',
        'bitonal_threshold_dpi': 'float',
        'clip_images': 'bool',
        'continuous_compressions': 'list[str]',
        'linearize': 'bool',
        'image_quality': 'int',
        'indexed_compressions': 'list[str]',
        'dithering_mode': 'str',
        'color_resolution_dpi': 'float',
        'color_threshold_dpi': 'float',
        'monochrome_resolution_dpi': 'float',
        'monochrome_threshold_dpi': 'float',
        'resolution_dpi': 'int',
        'threshold_dpi': 'int',
        'strip': 'list[str]',
        'info_entries': 'list[KeyValuePairStringString]',
        'flatten_signature_fields': 'bool'
    }

    attribute_map = {
        'profile': 'profile',
        'use_profile': 'useProfile',
        'remove_redundant_objects': 'removeRedundantObjects',
        'subset_fonts': 'subsetFonts',
        'optimize_resources': 'optimizeResources',
        'force_compression_types': 'forceCompressionTypes',
        'force_recompression': 'forceRecompression',
        'reduce_color_complexity': 'reduceColorComplexity',
        'merge_embedded_fonts': 'mergeEmbeddedFonts',
        'bitonal_compressions': 'bitonalCompressions',
        'bitonal_resolution_dpi': 'bitonalResolutionDPI',
        'bitonal_threshold_dpi': 'bitonalThresholdDPI',
        'clip_images': 'clipImages',
        'continuous_compressions': 'continuousCompressions',
        'linearize': 'linearize',
        'image_quality': 'imageQuality',
        'indexed_compressions': 'indexedCompressions',
        'dithering_mode': 'ditheringMode',
        'color_resolution_dpi': 'colorResolutionDPI',
        'color_threshold_dpi': 'colorThresholdDPI',
        'monochrome_resolution_dpi': 'monochromeResolutionDPI',
        'monochrome_threshold_dpi': 'monochromeThresholdDPI',
        'resolution_dpi': 'resolutionDPI',
        'threshold_dpi': 'thresholdDPI',
        'strip': 'strip',
        'info_entries': 'infoEntries',
        'flatten_signature_fields': 'flattenSignatureFields'
    }

    def __init__(self, profile=None, use_profile=None, remove_redundant_objects=None, subset_fonts=None, optimize_resources=None, force_compression_types=None, force_recompression=None, reduce_color_complexity=None, merge_embedded_fonts=None, bitonal_compressions=None, bitonal_resolution_dpi=None, bitonal_threshold_dpi=None, clip_images=None, continuous_compressions=None, linearize=None, image_quality=None, indexed_compressions=None, dithering_mode=None, color_resolution_dpi=None, color_threshold_dpi=None, monochrome_resolution_dpi=None, monochrome_threshold_dpi=None, resolution_dpi=None, threshold_dpi=None, strip=None, info_entries=None, flatten_signature_fields=None):  # noqa: E501
        """OptimizeAction - a model defined in Swagger"""  # noqa: E501

        self._profile = None
        self._use_profile = None
        self._remove_redundant_objects = None
        self._subset_fonts = None
        self._optimize_resources = None
        self._force_compression_types = None
        self._force_recompression = None
        self._reduce_color_complexity = None
        self._merge_embedded_fonts = None
        self._bitonal_compressions = None
        self._bitonal_resolution_dpi = None
        self._bitonal_threshold_dpi = None
        self._clip_images = None
        self._continuous_compressions = None
        self._linearize = None
        self._image_quality = None
        self._indexed_compressions = None
        self._dithering_mode = None
        self._color_resolution_dpi = None
        self._color_threshold_dpi = None
        self._monochrome_resolution_dpi = None
        self._monochrome_threshold_dpi = None
        self._resolution_dpi = None
        self._threshold_dpi = None
        self._strip = None
        self._info_entries = None
        self._flatten_signature_fields = None
        self.discriminator = None

        if profile is not None:
            self.profile = profile
        self.use_profile = use_profile
        if remove_redundant_objects is not None:
            self.remove_redundant_objects = remove_redundant_objects
        if subset_fonts is not None:
            self.subset_fonts = subset_fonts
        if optimize_resources is not None:
            self.optimize_resources = optimize_resources
        if force_compression_types is not None:
            self.force_compression_types = force_compression_types
        if force_recompression is not None:
            self.force_recompression = force_recompression
        if reduce_color_complexity is not None:
            self.reduce_color_complexity = reduce_color_complexity
        if merge_embedded_fonts is not None:
            self.merge_embedded_fonts = merge_embedded_fonts
        if bitonal_compressions is not None:
            self.bitonal_compressions = bitonal_compressions
        if bitonal_resolution_dpi is not None:
            self.bitonal_resolution_dpi = bitonal_resolution_dpi
        if bitonal_threshold_dpi is not None:
            self.bitonal_threshold_dpi = bitonal_threshold_dpi
        if clip_images is not None:
            self.clip_images = clip_images
        if continuous_compressions is not None:
            self.continuous_compressions = continuous_compressions
        if linearize is not None:
            self.linearize = linearize
        if image_quality is not None:
            self.image_quality = image_quality
        if indexed_compressions is not None:
            self.indexed_compressions = indexed_compressions
        if dithering_mode is not None:
            self.dithering_mode = dithering_mode
        if color_resolution_dpi is not None:
            self.color_resolution_dpi = color_resolution_dpi
        if color_threshold_dpi is not None:
            self.color_threshold_dpi = color_threshold_dpi
        if monochrome_resolution_dpi is not None:
            self.monochrome_resolution_dpi = monochrome_resolution_dpi
        if monochrome_threshold_dpi is not None:
            self.monochrome_threshold_dpi = monochrome_threshold_dpi
        if resolution_dpi is not None:
            self.resolution_dpi = resolution_dpi
        if threshold_dpi is not None:
            self.threshold_dpi = threshold_dpi
        if strip is not None:
            self.strip = strip
        if info_entries is not None:
            self.info_entries = info_entries
        if flatten_signature_fields is not None:
            self.flatten_signature_fields = flatten_signature_fields

    @property
    def profile(self):
        """Gets the profile of this OptimizeAction.  # noqa: E501

        With this property one of the predefined optimization profiles can be set. If a profile is set then all the properties  listed in TPDFOptimizationProfile(table Profile Settings) are set to their respective values.Properties not  listed in this table are left unchanged.  One way of quickly arriving at a specific setting is to first set the Profile and then adapt the configuration by  setting some of the individual properties.  # noqa: E501

        :return: The profile of this OptimizeAction.  # noqa: E501
        :rtype: str
        """
        return self._profile

    @profile.setter
    def profile(self, profile):
        """Sets the profile of this OptimizeAction.

        With this property one of the predefined optimization profiles can be set. If a profile is set then all the properties  listed in TPDFOptimizationProfile(table Profile Settings) are set to their respective values.Properties not  listed in this table are left unchanged.  One way of quickly arriving at a specific setting is to first set the Profile and then adapt the configuration by  setting some of the individual properties.  # noqa: E501

        :param profile: The profile of this OptimizeAction.  # noqa: E501
        :type: str
        """
        allowed_values = ["max", "web", "print"]  # noqa: E501
        if profile not in allowed_values:
            raise ValueError(
                "Invalid value for `profile` ({0}), must be one of {1}"  # noqa: E501
                .format(profile, allowed_values)
            )

        self._profile = profile

    @property
    def use_profile(self):
        """Gets the use_profile of this OptimizeAction.  # noqa: E501


        :return: The use_profile of this OptimizeAction.  # noqa: E501
        :rtype: bool
        """
        return self._use_profile

    @use_profile.setter
    def use_profile(self, use_profile):
        """Sets the use_profile of this OptimizeAction.


        :param use_profile: The use_profile of this OptimizeAction.  # noqa: E501
        :type: bool
        """
        if use_profile is None:
            raise ValueError("Invalid value for `use_profile`, must not be `None`")  # noqa: E501

        self._use_profile = use_profile

    @property
    def remove_redundant_objects(self):
        """Gets the remove_redundant_objects of this OptimizeAction.  # noqa: E501

        Get or set whether redundant objects should be removed. If this property is  set to True, duplicate objects are removed in order to reduce the file size.    {default: false}  # noqa: E501

        :return: The remove_redundant_objects of this OptimizeAction.  # noqa: E501
        :rtype: bool
        """
        return self._remove_redundant_objects

    @remove_redundant_objects.setter
    def remove_redundant_objects(self, remove_redundant_objects):
        """Sets the remove_redundant_objects of this OptimizeAction.

        Get or set whether redundant objects should be removed. If this property is  set to True, duplicate objects are removed in order to reduce the file size.    {default: false}  # noqa: E501

        :param remove_redundant_objects: The remove_redundant_objects of this OptimizeAction.  # noqa: E501
        :type: bool
        """

        self._remove_redundant_objects = remove_redundant_objects

    @property
    def subset_fonts(self):
        """Gets the subset_fonts of this OptimizeAction.  # noqa: E501

        This property influences two optimizations related to subsetted fonts:  - Subset embedded fonts.  - Merge embedded font programs of different subsets of the same font, granted they can be merged.   <para>  Sub-setting refers to removing those glyphs in a font that are not actually  used in any text contained in the PDF.   </para>{default: false}  # noqa: E501

        :return: The subset_fonts of this OptimizeAction.  # noqa: E501
        :rtype: bool
        """
        return self._subset_fonts

    @subset_fonts.setter
    def subset_fonts(self, subset_fonts):
        """Sets the subset_fonts of this OptimizeAction.

        This property influences two optimizations related to subsetted fonts:  - Subset embedded fonts.  - Merge embedded font programs of different subsets of the same font, granted they can be merged.   <para>  Sub-setting refers to removing those glyphs in a font that are not actually  used in any text contained in the PDF.   </para>{default: false}  # noqa: E501

        :param subset_fonts: The subset_fonts of this OptimizeAction.  # noqa: E501
        :type: bool
        """

        self._subset_fonts = subset_fonts

    @property
    def optimize_resources(self):
        """Gets the optimize_resources of this OptimizeAction.  # noqa: E501

        Get or set whether resources should be optimized. If set, unused resources  such as images, fonts, and color spaces are removed.Also content streams  are re-built.    {default: false}  # noqa: E501

        :return: The optimize_resources of this OptimizeAction.  # noqa: E501
        :rtype: bool
        """
        return self._optimize_resources

    @optimize_resources.setter
    def optimize_resources(self, optimize_resources):
        """Sets the optimize_resources of this OptimizeAction.

        Get or set whether resources should be optimized. If set, unused resources  such as images, fonts, and color spaces are removed.Also content streams  are re-built.    {default: false}  # noqa: E501

        :param optimize_resources: The optimize_resources of this OptimizeAction.  # noqa: E501
        :type: bool
        """

        self._optimize_resources = optimize_resources

    @property
    def force_compression_types(self):
        """Gets the force_compression_types of this OptimizeAction.  # noqa: E501

        If this option is set, then re-compression of images is forced if an image in the  input PDF has a compression type that differs from the compression types  given in ContinuousCompressions, BitonalCompressions, or IndexedCompressions. Use this option if you want to allow only the given  compression types for images in the output PDF.  {default: false}  # noqa: E501

        :return: The force_compression_types of this OptimizeAction.  # noqa: E501
        :rtype: bool
        """
        return self._force_compression_types

    @force_compression_types.setter
    def force_compression_types(self, force_compression_types):
        """Sets the force_compression_types of this OptimizeAction.

        If this option is set, then re-compression of images is forced if an image in the  input PDF has a compression type that differs from the compression types  given in ContinuousCompressions, BitonalCompressions, or IndexedCompressions. Use this option if you want to allow only the given  compression types for images in the output PDF.  {default: false}  # noqa: E501

        :param force_compression_types: The force_compression_types of this OptimizeAction.  # noqa: E501
        :type: bool
        """

        self._force_compression_types = force_compression_types

    @property
    def force_recompression(self):
        """Gets the force_recompression of this OptimizeAction.  # noqa: E501

        If set, all images are always recompressed.If not set (default), images are only  recompressed if the resulting image is smaller than the original, i.e.requires  less bytes to store in the file.    {default: false}  # noqa: E501

        :return: The force_recompression of this OptimizeAction.  # noqa: E501
        :rtype: bool
        """
        return self._force_recompression

    @force_recompression.setter
    def force_recompression(self, force_recompression):
        """Sets the force_recompression of this OptimizeAction.

        If set, all images are always recompressed.If not set (default), images are only  recompressed if the resulting image is smaller than the original, i.e.requires  less bytes to store in the file.    {default: false}  # noqa: E501

        :param force_recompression: The force_recompression of this OptimizeAction.  # noqa: E501
        :type: bool
        """

        self._force_recompression = force_recompression

    @property
    def reduce_color_complexity(self):
        """Gets the reduce_color_complexity of this OptimizeAction.  # noqa: E501

        This property is used to enable color complexity reduction of images. (See  also Provided Features for Optimizing Images.)  If enabled then images with device color spaces(DeviceRGB, DeviceCMYK,  or DeviceGray) and indexed images with a device color space as base color  space are analyzed and if possible converted as follows:  - An image with DeviceRGB or DeviceCMYK color space in which all pixels  are gray is converted to a grayscale image with DeviceGray color space.  - An image that contains only black and white pixels is converted into a bitonal image.  - An image in which all the pixels have the same color is down-sampled to one pixel.  Furthermore, images’ masks and soft masks are optimized as follows:  - A soft mask that contains only black and white pixels is converted to a mask.  - A (soft) mask that is opaque is removed.    {default: false}  # noqa: E501

        :return: The reduce_color_complexity of this OptimizeAction.  # noqa: E501
        :rtype: bool
        """
        return self._reduce_color_complexity

    @reduce_color_complexity.setter
    def reduce_color_complexity(self, reduce_color_complexity):
        """Sets the reduce_color_complexity of this OptimizeAction.

        This property is used to enable color complexity reduction of images. (See  also Provided Features for Optimizing Images.)  If enabled then images with device color spaces(DeviceRGB, DeviceCMYK,  or DeviceGray) and indexed images with a device color space as base color  space are analyzed and if possible converted as follows:  - An image with DeviceRGB or DeviceCMYK color space in which all pixels  are gray is converted to a grayscale image with DeviceGray color space.  - An image that contains only black and white pixels is converted into a bitonal image.  - An image in which all the pixels have the same color is down-sampled to one pixel.  Furthermore, images’ masks and soft masks are optimized as follows:  - A soft mask that contains only black and white pixels is converted to a mask.  - A (soft) mask that is opaque is removed.    {default: false}  # noqa: E501

        :param reduce_color_complexity: The reduce_color_complexity of this OptimizeAction.  # noqa: E501
        :type: bool
        """

        self._reduce_color_complexity = reduce_color_complexity

    @property
    def merge_embedded_fonts(self):
        """Gets the merge_embedded_fonts of this OptimizeAction.  # noqa: E501

        Merge embedded font programs. Font programs can be merged, if they  originate from the same font, e.g.they are of the same type, have the same  name and encoding.Merging of Type1(PostScript) and TrueType fonts is supported.  # noqa: E501

        :return: The merge_embedded_fonts of this OptimizeAction.  # noqa: E501
        :rtype: bool
        """
        return self._merge_embedded_fonts

    @merge_embedded_fonts.setter
    def merge_embedded_fonts(self, merge_embedded_fonts):
        """Sets the merge_embedded_fonts of this OptimizeAction.

        Merge embedded font programs. Font programs can be merged, if they  originate from the same font, e.g.they are of the same type, have the same  name and encoding.Merging of Type1(PostScript) and TrueType fonts is supported.  # noqa: E501

        :param merge_embedded_fonts: The merge_embedded_fonts of this OptimizeAction.  # noqa: E501
        :type: bool
        """

        self._merge_embedded_fonts = merge_embedded_fonts

    @property
    def bitonal_compressions(self):
        """Gets the bitonal_compressions of this OptimizeAction.  # noqa: E501

        Get or set the compression types for bi-tonal images.  Several values can be combined.The following values are allowed:  ComprAttemptNone  ComprAttemptRaw  ComprAttemptFlate  ComprAttemptLZW  ComprAttemptGroup3  ComprAttemptGroup4  ComprAttemptSource  ComprAttemptJBIG2  Other values are ignored.   <para>  During optimization, all set compression types are tried and the one resulting in the least memory footprint is taken.  Typically, CCITT Group 4 or JBIG2 is used for bi-tonal compression. Due to the simpler algorithm CCITT Group 4 has  the advantage of being faster. JBIG2 can achieve compression ratios that are up to twice as high as CCITT Group 4  at the cost of longer computation time.   </para>{default: ComprAttemptNone}  # noqa: E501

        :return: The bitonal_compressions of this OptimizeAction.  # noqa: E501
        :rtype: list[str]
        """
        return self._bitonal_compressions

    @bitonal_compressions.setter
    def bitonal_compressions(self, bitonal_compressions):
        """Sets the bitonal_compressions of this OptimizeAction.

        Get or set the compression types for bi-tonal images.  Several values can be combined.The following values are allowed:  ComprAttemptNone  ComprAttemptRaw  ComprAttemptFlate  ComprAttemptLZW  ComprAttemptGroup3  ComprAttemptGroup4  ComprAttemptSource  ComprAttemptJBIG2  Other values are ignored.   <para>  During optimization, all set compression types are tried and the one resulting in the least memory footprint is taken.  Typically, CCITT Group 4 or JBIG2 is used for bi-tonal compression. Due to the simpler algorithm CCITT Group 4 has  the advantage of being faster. JBIG2 can achieve compression ratios that are up to twice as high as CCITT Group 4  at the cost of longer computation time.   </para>{default: ComprAttemptNone}  # noqa: E501

        :param bitonal_compressions: The bitonal_compressions of this OptimizeAction.  # noqa: E501
        :type: list[str]
        """
        allowed_values = ["none", "raw", "jPEG", "flate", "lZW", "group3", "group3_2D", "group4", "jBIG2", "jPEG2000", "mRC", "source"]  # noqa: E501
        if not set(bitonal_compressions).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `bitonal_compressions` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(bitonal_compressions) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._bitonal_compressions = bitonal_compressions

    @property
    def bitonal_resolution_dpi(self):
        """Gets the bitonal_resolution_dpi of this OptimizeAction.  # noqa: E501

        Get or set the target resolution in dots per inch (DPI) after re-sampling images  for bi-tonal images.See also ResolutionDPI.    {default: 200}  # noqa: E501

        :return: The bitonal_resolution_dpi of this OptimizeAction.  # noqa: E501
        :rtype: float
        """
        return self._bitonal_resolution_dpi

    @bitonal_resolution_dpi.setter
    def bitonal_resolution_dpi(self, bitonal_resolution_dpi):
        """Sets the bitonal_resolution_dpi of this OptimizeAction.

        Get or set the target resolution in dots per inch (DPI) after re-sampling images  for bi-tonal images.See also ResolutionDPI.    {default: 200}  # noqa: E501

        :param bitonal_resolution_dpi: The bitonal_resolution_dpi of this OptimizeAction.  # noqa: E501
        :type: float
        """

        self._bitonal_resolution_dpi = bitonal_resolution_dpi

    @property
    def bitonal_threshold_dpi(self):
        """Gets the bitonal_threshold_dpi of this OptimizeAction.  # noqa: E501

        Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for bi-tonal images.The value -1 deactivates re-sampling for bitonal images. See also ThresholdDPI.    {default: -1}  # noqa: E501

        :return: The bitonal_threshold_dpi of this OptimizeAction.  # noqa: E501
        :rtype: float
        """
        return self._bitonal_threshold_dpi

    @bitonal_threshold_dpi.setter
    def bitonal_threshold_dpi(self, bitonal_threshold_dpi):
        """Sets the bitonal_threshold_dpi of this OptimizeAction.

        Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for bi-tonal images.The value -1 deactivates re-sampling for bitonal images. See also ThresholdDPI.    {default: -1}  # noqa: E501

        :param bitonal_threshold_dpi: The bitonal_threshold_dpi of this OptimizeAction.  # noqa: E501
        :type: float
        """

        self._bitonal_threshold_dpi = bitonal_threshold_dpi

    @property
    def clip_images(self):
        """Gets the clip_images of this OptimizeAction.  # noqa: E501

        Get or set the option to clip images. When enabled, then invisible parts of images are clipped (cropped).   While this does not affect visual parts of images, it may have a minor visual impact because clipped   images are re-compressed. Pre-blended images are not clipped. Enabling this property will also   enable the OptimizeResources property.                {default: false}  # noqa: E501

        :return: The clip_images of this OptimizeAction.  # noqa: E501
        :rtype: bool
        """
        return self._clip_images

    @clip_images.setter
    def clip_images(self, clip_images):
        """Sets the clip_images of this OptimizeAction.

        Get or set the option to clip images. When enabled, then invisible parts of images are clipped (cropped).   While this does not affect visual parts of images, it may have a minor visual impact because clipped   images are re-compressed. Pre-blended images are not clipped. Enabling this property will also   enable the OptimizeResources property.                {default: false}  # noqa: E501

        :param clip_images: The clip_images of this OptimizeAction.  # noqa: E501
        :type: bool
        """

        self._clip_images = clip_images

    @property
    def continuous_compressions(self):
        """Gets the continuous_compressions of this OptimizeAction.  # noqa: E501

        Get or set the compression types to be tried for continuous images, i.e. RGB, CMYK, and grayscale images.  See also TPDFComprAttempt. Several values can be combined with bitwise or operators.  Other values are ignored. During optimization, all set compression types are tried and the one resulting in   the least memory footprint is taken.    {default: ComprAttemptNone}  # noqa: E501

        :return: The continuous_compressions of this OptimizeAction.  # noqa: E501
        :rtype: list[str]
        """
        return self._continuous_compressions

    @continuous_compressions.setter
    def continuous_compressions(self, continuous_compressions):
        """Sets the continuous_compressions of this OptimizeAction.

        Get or set the compression types to be tried for continuous images, i.e. RGB, CMYK, and grayscale images.  See also TPDFComprAttempt. Several values can be combined with bitwise or operators.  Other values are ignored. During optimization, all set compression types are tried and the one resulting in   the least memory footprint is taken.    {default: ComprAttemptNone}  # noqa: E501

        :param continuous_compressions: The continuous_compressions of this OptimizeAction.  # noqa: E501
        :type: list[str]
        """
        allowed_values = ["none", "raw", "jPEG", "flate", "lZW", "group3", "group3_2D", "group4", "jBIG2", "jPEG2000", "mRC", "source"]  # noqa: E501
        if not set(continuous_compressions).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `continuous_compressions` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(continuous_compressions) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._continuous_compressions = continuous_compressions

    @property
    def linearize(self):
        """Gets the linearize of this OptimizeAction.  # noqa: E501

        Get or set whether to linearize the PDF output file, i.e. optimize file for fast web access.   A linearized document has a slightly larger file size than a non-linearized file and provides the following main features:   - When a document is opened in a PDF viewer of a web browser, the first page can be viewed without downloading the entire   PDF file.In contrast, a non-linearized PDF file must be downloaded completely before the first page can be displayed.  - When another page is requested by the user, that page is displayed as quickly as possible and incrementally as   data arrives, without downloading the entire PDF file.   <para>  Signed files cannot be linearizes. So this property must be set to False if a digital signature is applied.   </para>{default: false}  # noqa: E501

        :return: The linearize of this OptimizeAction.  # noqa: E501
        :rtype: bool
        """
        return self._linearize

    @linearize.setter
    def linearize(self, linearize):
        """Sets the linearize of this OptimizeAction.

        Get or set whether to linearize the PDF output file, i.e. optimize file for fast web access.   A linearized document has a slightly larger file size than a non-linearized file and provides the following main features:   - When a document is opened in a PDF viewer of a web browser, the first page can be viewed without downloading the entire   PDF file.In contrast, a non-linearized PDF file must be downloaded completely before the first page can be displayed.  - When another page is requested by the user, that page is displayed as quickly as possible and incrementally as   data arrives, without downloading the entire PDF file.   <para>  Signed files cannot be linearizes. So this property must be set to False if a digital signature is applied.   </para>{default: false}  # noqa: E501

        :param linearize: The linearize of this OptimizeAction.  # noqa: E501
        :type: bool
        """

        self._linearize = linearize

    @property
    def image_quality(self):
        """Gets the image_quality of this OptimizeAction.  # noqa: E501

        Get or set the quality index of lossy compression types. This value ranges   from 1 to 100 and is applied to JPEG and JPEG2000 compression.For  JPEG2000, a quality index of 100 means lossless compression.JPEG compression is always lossy.    {default: 75}  # noqa: E501

        :return: The image_quality of this OptimizeAction.  # noqa: E501
        :rtype: int
        """
        return self._image_quality

    @image_quality.setter
    def image_quality(self, image_quality):
        """Sets the image_quality of this OptimizeAction.

        Get or set the quality index of lossy compression types. This value ranges   from 1 to 100 and is applied to JPEG and JPEG2000 compression.For  JPEG2000, a quality index of 100 means lossless compression.JPEG compression is always lossy.    {default: 75}  # noqa: E501

        :param image_quality: The image_quality of this OptimizeAction.  # noqa: E501
        :type: int
        """

        self._image_quality = image_quality

    @property
    def indexed_compressions(self):
        """Gets the indexed_compressions of this OptimizeAction.  # noqa: E501

        Get or set the compression types for images that have an indexed (“palette”)  color space.See also TPDFComprAttempt.  Several values can be combined with bitwise or operators.The following values are allowed:  - ComprAttemptNone  - ComprAttemptRaw  - ComprAttemptFlate  - ComprAttemptLZW  - ComprAttemptSource  Other values are ignored.   <para>  During optimization, all set compression types are tried and the one resulting in the least memory footprint is taken.   </para>{default: ComprAttemptFlate}  # noqa: E501

        :return: The indexed_compressions of this OptimizeAction.  # noqa: E501
        :rtype: list[str]
        """
        return self._indexed_compressions

    @indexed_compressions.setter
    def indexed_compressions(self, indexed_compressions):
        """Sets the indexed_compressions of this OptimizeAction.

        Get or set the compression types for images that have an indexed (“palette”)  color space.See also TPDFComprAttempt.  Several values can be combined with bitwise or operators.The following values are allowed:  - ComprAttemptNone  - ComprAttemptRaw  - ComprAttemptFlate  - ComprAttemptLZW  - ComprAttemptSource  Other values are ignored.   <para>  During optimization, all set compression types are tried and the one resulting in the least memory footprint is taken.   </para>{default: ComprAttemptFlate}  # noqa: E501

        :param indexed_compressions: The indexed_compressions of this OptimizeAction.  # noqa: E501
        :type: list[str]
        """
        allowed_values = ["none", "raw", "jPEG", "flate", "lZW", "group3", "group3_2D", "group4", "jBIG2", "jPEG2000", "mRC", "source"]  # noqa: E501
        if not set(indexed_compressions).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `indexed_compressions` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(indexed_compressions) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._indexed_compressions = indexed_compressions

    @property
    def dithering_mode(self):
        """Gets the dithering_mode of this OptimizeAction.  # noqa: E501

        This option enables or disables dithering when down-sampling bi-tonal images.  The only values supported are eDitherNone and eDitherFloydSteinberg.  Some bi-tonal images try to evoke the impression of different levels of gray   by randomly setting pixels to black.If dithering is applied during downsampling    then the gray levels of such images are preserved better.If dithering is switched    off then lines (e.g.text glyphs) are preserved better.      {default: DitherNone}  # noqa: E501

        :return: The dithering_mode of this OptimizeAction.  # noqa: E501
        :rtype: str
        """
        return self._dithering_mode

    @dithering_mode.setter
    def dithering_mode(self, dithering_mode):
        """Sets the dithering_mode of this OptimizeAction.

        This option enables or disables dithering when down-sampling bi-tonal images.  The only values supported are eDitherNone and eDitherFloydSteinberg.  Some bi-tonal images try to evoke the impression of different levels of gray   by randomly setting pixels to black.If dithering is applied during downsampling    then the gray levels of such images are preserved better.If dithering is switched    off then lines (e.g.text glyphs) are preserved better.      {default: DitherNone}  # noqa: E501

        :param dithering_mode: The dithering_mode of this OptimizeAction.  # noqa: E501
        :type: str
        """
        allowed_values = ["none", "floydSteinberg", "halftone", "pattern", "g3Optimized", "g4Optimized", "atkinson"]  # noqa: E501
        if dithering_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `dithering_mode` ({0}), must be one of {1}"  # noqa: E501
                .format(dithering_mode, allowed_values)
            )

        self._dithering_mode = dithering_mode

    @property
    def color_resolution_dpi(self):
        """Gets the color_resolution_dpi of this OptimizeAction.  # noqa: E501

        Get or set the target resolution in dots per inch (DPI) after re-sampling images  for color images.See also ResolutionDPI.    {default: 150}  # noqa: E501

        :return: The color_resolution_dpi of this OptimizeAction.  # noqa: E501
        :rtype: float
        """
        return self._color_resolution_dpi

    @color_resolution_dpi.setter
    def color_resolution_dpi(self, color_resolution_dpi):
        """Sets the color_resolution_dpi of this OptimizeAction.

        Get or set the target resolution in dots per inch (DPI) after re-sampling images  for color images.See also ResolutionDPI.    {default: 150}  # noqa: E501

        :param color_resolution_dpi: The color_resolution_dpi of this OptimizeAction.  # noqa: E501
        :type: float
        """

        self._color_resolution_dpi = color_resolution_dpi

    @property
    def color_threshold_dpi(self):
        """Gets the color_threshold_dpi of this OptimizeAction.  # noqa: E501

        Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for color images.The value -1 deactivates re-sampling for color  images. See also ThresholdDPI.    {default: -1}  # noqa: E501

        :return: The color_threshold_dpi of this OptimizeAction.  # noqa: E501
        :rtype: float
        """
        return self._color_threshold_dpi

    @color_threshold_dpi.setter
    def color_threshold_dpi(self, color_threshold_dpi):
        """Sets the color_threshold_dpi of this OptimizeAction.

        Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for color images.The value -1 deactivates re-sampling for color  images. See also ThresholdDPI.    {default: -1}  # noqa: E501

        :param color_threshold_dpi: The color_threshold_dpi of this OptimizeAction.  # noqa: E501
        :type: float
        """

        self._color_threshold_dpi = color_threshold_dpi

    @property
    def monochrome_resolution_dpi(self):
        """Gets the monochrome_resolution_dpi of this OptimizeAction.  # noqa: E501

        Get or set target resolution in dots per inch (DPI) after re-sampling images  for monochrome images.See also ResolutionDPI.    {default: 150}  # noqa: E501

        :return: The monochrome_resolution_dpi of this OptimizeAction.  # noqa: E501
        :rtype: float
        """
        return self._monochrome_resolution_dpi

    @monochrome_resolution_dpi.setter
    def monochrome_resolution_dpi(self, monochrome_resolution_dpi):
        """Sets the monochrome_resolution_dpi of this OptimizeAction.

        Get or set target resolution in dots per inch (DPI) after re-sampling images  for monochrome images.See also ResolutionDPI.    {default: 150}  # noqa: E501

        :param monochrome_resolution_dpi: The monochrome_resolution_dpi of this OptimizeAction.  # noqa: E501
        :type: float
        """

        self._monochrome_resolution_dpi = monochrome_resolution_dpi

    @property
    def monochrome_threshold_dpi(self):
        """Gets the monochrome_threshold_dpi of this OptimizeAction.  # noqa: E501

        Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for monochrome images.The value -1 deactivates re-sampling  for monochrome images. See also ThresholdDPI.    {default: -1}  # noqa: E501

        :return: The monochrome_threshold_dpi of this OptimizeAction.  # noqa: E501
        :rtype: float
        """
        return self._monochrome_threshold_dpi

    @monochrome_threshold_dpi.setter
    def monochrome_threshold_dpi(self, monochrome_threshold_dpi):
        """Sets the monochrome_threshold_dpi of this OptimizeAction.

        Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for monochrome images.The value -1 deactivates re-sampling  for monochrome images. See also ThresholdDPI.    {default: -1}  # noqa: E501

        :param monochrome_threshold_dpi: The monochrome_threshold_dpi of this OptimizeAction.  # noqa: E501
        :type: float
        """

        self._monochrome_threshold_dpi = monochrome_threshold_dpi

    @property
    def resolution_dpi(self):
        """Gets the resolution_dpi of this OptimizeAction.  # noqa: E501

        Get or set the resolution in DPI (dots per inch) after re-sampling images.  This property affects all three image compression types(BitonalResolutionDPI, ColorResolutionDPI, MonochromeResolutionDPI).  A typical value for the resolution when optimizing for the web is 150 DPI.For  printing typically no re-sampling is applied(see property ThresholdDPI).  Pre-blended images, images with a color key mask, mask, and soft mask images are not re-sampled.  When getting ResolutionDPI, the property returns the target resolution in DPI for color images.    {default: Different defaults apply to different image types}  # noqa: E501

        :return: The resolution_dpi of this OptimizeAction.  # noqa: E501
        :rtype: int
        """
        return self._resolution_dpi

    @resolution_dpi.setter
    def resolution_dpi(self, resolution_dpi):
        """Sets the resolution_dpi of this OptimizeAction.

        Get or set the resolution in DPI (dots per inch) after re-sampling images.  This property affects all three image compression types(BitonalResolutionDPI, ColorResolutionDPI, MonochromeResolutionDPI).  A typical value for the resolution when optimizing for the web is 150 DPI.For  printing typically no re-sampling is applied(see property ThresholdDPI).  Pre-blended images, images with a color key mask, mask, and soft mask images are not re-sampled.  When getting ResolutionDPI, the property returns the target resolution in DPI for color images.    {default: Different defaults apply to different image types}  # noqa: E501

        :param resolution_dpi: The resolution_dpi of this OptimizeAction.  # noqa: E501
        :type: int
        """

        self._resolution_dpi = resolution_dpi

    @property
    def threshold_dpi(self):
        """Gets the threshold_dpi of this OptimizeAction.  # noqa: E501

        Set the threshold in DPI (dots per inch) to selectively activate re-sampling.  Only images with a resolution above the threshold DPI will be re-sampled.  This property affects all three image compression types(BitonalThresholdDPI, ColorThresholdDPI, MonochromeThresholdDPI). The  value -1 deactivates re-sampling.    {default: -1}  # noqa: E501

        :return: The threshold_dpi of this OptimizeAction.  # noqa: E501
        :rtype: int
        """
        return self._threshold_dpi

    @threshold_dpi.setter
    def threshold_dpi(self, threshold_dpi):
        """Sets the threshold_dpi of this OptimizeAction.

        Set the threshold in DPI (dots per inch) to selectively activate re-sampling.  Only images with a resolution above the threshold DPI will be re-sampled.  This property affects all three image compression types(BitonalThresholdDPI, ColorThresholdDPI, MonochromeThresholdDPI). The  value -1 deactivates re-sampling.    {default: -1}  # noqa: E501

        :param threshold_dpi: The threshold_dpi of this OptimizeAction.  # noqa: E501
        :type: int
        """

        self._threshold_dpi = threshold_dpi

    @property
    def strip(self):
        """Gets the strip of this OptimizeAction.  # noqa: E501

         Get or set the stripping mode. This mode can be configured to remove unneeded data of a PDF document such as Threads, Metadata, the PieceInfo,  the StructTreeRoot entry, embedded Thumbs and the SpiderInfo entry.Also  this mode is used to indicate whether to flatten form fields, links, and other  annotations.Multiple values of TPDFStripType can be combined with the  bitwise or operator.     {default: StripThreads}  # noqa: E501

        :return: The strip of this OptimizeAction.  # noqa: E501
        :rtype: list[str]
        """
        return self._strip

    @strip.setter
    def strip(self, strip):
        """Sets the strip of this OptimizeAction.

         Get or set the stripping mode. This mode can be configured to remove unneeded data of a PDF document such as Threads, Metadata, the PieceInfo,  the StructTreeRoot entry, embedded Thumbs and the SpiderInfo entry.Also  this mode is used to indicate whether to flatten form fields, links, and other  annotations.Multiple values of TPDFStripType can be combined with the  bitwise or operator.     {default: StripThreads}  # noqa: E501

        :param strip: The strip of this OptimizeAction.  # noqa: E501
        :type: list[str]
        """
        allowed_values = ["threads", "metadata", "pieceInfo", "structTree", "thumb", "spider", "alternates", "forms", "links", "annots", "formsAnnots", "outputIntents", "all"]  # noqa: E501
        if not set(strip).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `strip` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(strip) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._strip = strip

    @property
    def info_entries(self):
        """Gets the info_entries of this OptimizeAction.  # noqa: E501

         Set a key-value pair in the document info dictionary. Values of predefined keys are also stored in the XMP metadata.  Popular entries specified in the PDF Reference 1.7 and accepted by most PDF viewers are \"Title\", \"Author\",  \"Subject\", \"Creator\" (sometimes referred to as Application), and \"Producer\" (sometimes referred to as   PDF Creator).  # noqa: E501

        :return: The info_entries of this OptimizeAction.  # noqa: E501
        :rtype: list[KeyValuePairStringString]
        """
        return self._info_entries

    @info_entries.setter
    def info_entries(self, info_entries):
        """Sets the info_entries of this OptimizeAction.

         Set a key-value pair in the document info dictionary. Values of predefined keys are also stored in the XMP metadata.  Popular entries specified in the PDF Reference 1.7 and accepted by most PDF viewers are \"Title\", \"Author\",  \"Subject\", \"Creator\" (sometimes referred to as Application), and \"Producer\" (sometimes referred to as   PDF Creator).  # noqa: E501

        :param info_entries: The info_entries of this OptimizeAction.  # noqa: E501
        :type: list[KeyValuePairStringString]
        """

        self._info_entries = info_entries

    @property
    def flatten_signature_fields(self):
        """Gets the flatten_signature_fields of this OptimizeAction.  # noqa: E501

        A signature in a PDF consist of two parts:  a.The invisible digital signature in the PDF.  b.The visual appearance that was attributed to the signature.  Part (a) can be used by a viewing application, to verify that a document has not changed since it has been signed  and report this to the user.Part(b) is merely a “decorative” element on the page without further significance.  When optimizing a PDF, the PDF is altered and hence the digital signature is broken.Therefore, all signatures are removed  , including parts(a) and(b).  When the property FlattenSignatureFields is set to True, then digital signatures(parts (a)) are still removed,  but their visual appearances(parts (b)) are flattened.I.e.the latter are retained and drawn as non-editable graphic  onto the page.  <para>  Note: The resulting PDF can be misleading as it visually appears to be signed,  but it has no digital signature and hence, a viewer application does not report any  broken signature.In most cases, such a behavior is undesirable</para>  # noqa: E501

        :return: The flatten_signature_fields of this OptimizeAction.  # noqa: E501
        :rtype: bool
        """
        return self._flatten_signature_fields

    @flatten_signature_fields.setter
    def flatten_signature_fields(self, flatten_signature_fields):
        """Sets the flatten_signature_fields of this OptimizeAction.

        A signature in a PDF consist of two parts:  a.The invisible digital signature in the PDF.  b.The visual appearance that was attributed to the signature.  Part (a) can be used by a viewing application, to verify that a document has not changed since it has been signed  and report this to the user.Part(b) is merely a “decorative” element on the page without further significance.  When optimizing a PDF, the PDF is altered and hence the digital signature is broken.Therefore, all signatures are removed  , including parts(a) and(b).  When the property FlattenSignatureFields is set to True, then digital signatures(parts (a)) are still removed,  but their visual appearances(parts (b)) are flattened.I.e.the latter are retained and drawn as non-editable graphic  onto the page.  <para>  Note: The resulting PDF can be misleading as it visually appears to be signed,  but it has no digital signature and hence, a viewer application does not report any  broken signature.In most cases, such a behavior is undesirable</para>  # noqa: E501

        :param flatten_signature_fields: The flatten_signature_fields of this OptimizeAction.  # noqa: E501
        :type: bool
        """

        self._flatten_signature_fields = flatten_signature_fields

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(OptimizeAction, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, OptimizeAction):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
